# [1920-수 찾기](https://www.acmicpc.net/problem/1920)

## 풀이

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n; cin >> n;
    int A[100000];
    for (int i=0; i<n; i++) {
        cin >> A[i];
    }
    int m; cin >> m;
    sort(A, A+n); // 배열 A를 정렬

    for (int i=0; i<m; i++) {
        int key; cin >> key;
        // 이분 탐색 시작
        int left = 0, right = n-1;
        bool found = false;
        
        while (left <= right) { // 이분탐색은 특정 값을 찾는게 조건이 오면 안되고 인덱스를 줄이는 게 관건
            int mid = (left + right) / 2;
            if (A[mid] == key) {
                found = true;
                break;
            } else if (A[mid] < key) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        if (found) {
            cout << 1 << "\n";
        } else {
            cout << 0 << "\n";
        }
    }
    
    return 0;
}

```


(복잡도 생략 가능)  
시간 복잡도 : O(mlogn) = O(logn) * m 

n : 주어진 배열
m : 찾는 숫자의 개수

## 회고(지나치게 간단한 문제는 생략 가능)
시간복잡도도 mlogn인데 시간초과가 뜨길래 당황했다. 코드를 보면서 어디서 실수 했는지 고민하다가 챗gpt 돌리니 금방 해결해줬다. 문제는 입출력 방식이었다. 
### 간단한 풀이와 접근 방식
시간제한을 통과하기 위해 이분탐색을 골랐고 다른 요소를 고민하려면 입출력방식이나 endl의 사용을 지양해야 한다.
입출력 방식 해결 :
```cpp
ios::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
```
이 3줄 코드를 작성해야 하는데 각 줄을 설명하면
1. ios::sync_with_stdio(0)은 C와 C++ 표준 stream의 동기화를 비활성화한다. 동기화되있을 때는 C 스타일(printf scanf)과 C++(cin cout)스타일의 입출력을 혼합해도 문제가 없지만 동기화를 해제하면 혼합하여 사용할 수 없게 된다. 대신 동기화 과정에서 소요되는 시간을 절약할 수 있다.
2. cin.tie(0) cout.tie(0)는 평소에는 cin.tie는 평소 cin과 cout을 묶어줍니다. 예를들어서 cout을 통해 출력이 끝난 뒤 cin으로 입력을 받을 수 있다. 하지만 묶음을 해제하면 출력이 되는 동시에 입력을 받을 수 있다. 프로그래밍상 부자연스러운 동작이지만 시간제한이 있는 알고리즘 문제를 풀때는 필요한 코드이다. 
endl은 단순히 줄바꿈을 추가하는 동작에 추가로 출력 버퍼를 강제로 플러시한다. 출력 작업이 완료된 직후에 데이터가 출력 장치로 전송되므로, 여러 번 호출하면 성능 저하를 일으킬 수 있다.

### 왜 그러한 풀이를 했는지? 

시간제한이 1초이기 때문에 알고리즘의 시간복잡도를 생각했다. 탐색 알고리즘중 빠른편인 이분탐색을 선택
더 빠른 탐색 알고리즘으로는 해시탐색이 있다. O(1)

### (틀렸다면) 오답 원인
입출력방식은 꽤나 중요하다는 것을 놓쳤다.

#### 왜 저 풀이를 떠올리지 못했을까?

알고리즘 문제를 풀때는 입출력방식을 최적화해주는 것을 습관화 하자 하지만 이는 단순히 알고리즘 문제를 통과하기 위한 수단일 뿐 실제 현업에서 남용하면 안된다.

---

## 참고

[알고리즘 문제 해결 전략 세트](https://product.kyobobook.co.kr/detail/S000001032946)에서 적당히 저한테 도움이 될 것 같은 형식으로 번형했습니다. 템플릿을 만든 이유는 단순히 문풀에서 끝나는게 아니라, 뭔가 남았으면 좋겠어서 만들어봤습니다. 
그러나 저는 늘상 문풀에는 약했기 때문에... 아마 도움이 안 될 수도 있을 것 같습니다.
다른 방식의 접근이 좋겠다라고 생각하시면 다른 템플릿을 사용하셔도 무방합니다. 책에서 제시하는 문제 해결 알고리즘 은 아래와 같습니다.

> 1. 문제를 읽고 이해한다.
> 2. 문제를 익숙한 용어로 재정의한다.
> 3. 어떻게 해결할지 계획을 세운다.
> 4. 계획을 검증한다.
> 5. 프로그램으로 구현한다.
> 6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

저는 6에 중점을 두어 템플릿을 만들었습니다.  

### 문제 해결 전략

체계적인 접근을 위한 질문

> 1. 비슷한 문제를 풀어본 적이 있나?
> 2. Brute-force?
> 3. 문제 푸는 과정을 수식화 할 수 있나?
> 4. 문제를 단순화 할 수 있나?(ex. 2d좌표 -> 1d 좌표)
> 5. 그림으로 그려볼 수 있나?
> 6. 문제를 수직으로 표현할 수 있나?
> 7. 문제를 분해/변형할 수 있나?(ex. 제약 조건 분리)
> 8. 역으로 생각할 수 있나?(ex. 사다리게임에서 꽝을 피하는 번호는?)
> 9. 순서를 강제할 수 있나?
> 10. 특정 형태의 답만을 고려할 수 있나?

 
