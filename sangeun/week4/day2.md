# [1629-곱](https://www.acmicpc.net/submit/1629/81546046)

## 풀이

```cpp
#include<iostream>
using namespace std;

using ll = long long;
ll recursion_mod(ll a, ll b, ll c){
    ll v = 0;
    if (b%2 == 1){
        if (b==1) return a%c;
        else return (recursion_mod(a, b-1, c)*a)%c;
    }
    v = recursion_mod(a,b/2,c);
    return v*v%c;
}

int main() {
    int a,b,c;
    cin >> a >> b >> c;
    cout << recursion_mod(a,b,c);
    return 0;
}
```

(복잡도 생략 가능)  
시간 복잡도 : O(lonN)  

N : b의 크기

## 회고(지나치게 간단한 문제는 생략 가능)
감이 안잡혀서 실제 수를 집어넣어 연산을 확인했다. mod 문제는 실제값 넣어서 확인하자
2  \             2  mod 3
    \         =      X
2   /  mod 3     2  mod 3

2^4mod3 = ((2^2mod3)^2)mod3 = ((((2mod3)^2)mod3)^2)mod3


### 간단한 풀이와 접근 방식
입력 A, B, C가 int 최대값 이하로 나오기 때문에 long long 타입으로 연산해야 하고 A^n에 대해서 n이 2이상이면 안된다.
따라서 위의 실제값 예시처럼 식을 변환시켜 n거듭제곱의 n을 1까지 내려줘야 한다. 
식의 꼴이 반복되기 때문에 재귀로 해결할 수 있으며 b가 b/2로 감소하기 때문에 O(logN)임을 알 수 있다. 

### 왜 그러한 풀이를 했는지? 

실제값의 식 변환에서 똑같은 형태가 반복되고 있음을 확인했음


## 참고

[알고리즘 문제 해결 전략 세트](https://product.kyobobook.co.kr/detail/S000001032946)에서 적당히 저한테 도움이 될 것 같은 형식으로 번형했습니다. 템플릿을 만든 이유는 단순히 문풀에서 끝나는게 아니라, 뭔가 남았으면 좋겠어서 만들어봤습니다. 
그러나 저는 늘상 문풀에는 약했기 때문에... 아마 도움이 안 될 수도 있을 것 같습니다.
다른 방식의 접근이 좋겠다라고 생각하시면 다른 템플릿을 사용하셔도 무방합니다. 책에서 제시하는 문제 해결 알고리즘 은 아래와 같습니다.

> 1. 문제를 읽고 이해한다.
> 2. 문제를 익숙한 용어로 재정의한다.
> 3. 어떻게 해결할지 계획을 세운다.
> 4. 계획을 검증한다.
> 5. 프로그램으로 구현한다.
> 6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

저는 6에 중점을 두어 템플릿을 만들었습니다.  

### 문제 해결 전략

체계적인 접근을 위한 질문

> 1. 비슷한 문제를 풀어본 적이 있나?
> 2. Brute-force?
> 3. 문제 푸는 과정을 수식화 할 수 있나?
> 4. 문제를 단순화 할 수 있나?(ex. 2d좌표 -> 1d 좌표)
> 5. 그림으로 그려볼 수 있나?
> 6. 문제를 수직으로 표현할 수 있나?
> 7. 문제를 분해/변형할 수 있나?(ex. 제약 조건 분리)
> 8. 역으로 생각할 수 있나?(ex. 사다리게임에서 꽝을 피하는 번호는?)
> 9. 순서를 강제할 수 있나?
> 10. 특정 형태의 답만을 고려할 수 있나?

 
