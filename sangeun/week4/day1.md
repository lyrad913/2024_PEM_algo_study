# [11728-배열 합치기](https://www.acmicpc.net/problem/11728)

## 풀이

```cpp
/*
첫째 줄에 배열 A의 크기 N, 배열 B의 크기 M이 주어진다. (1 ≤ N, M ≤ 1,000,000)

둘째 줄에는 배열 A의 내용이, 셋째 줄에는 배열 B의 내용이 주어진다. 
배열에 들어있는 수는 절댓값이 109보다 작거나 같은 정수이다.

출력
첫째 줄에 두 배열을 합친 후 정렬한 결과를 출력한다.
*/
#include<iostream>
using namespace std;

int main() {
    int a , b;
    int i;
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> a >> b;
    int arr1[a];
    int arr2[b];
    int arr3[a+b]; // 합친 결과를 넣을 배열
    
    for (i=0; i<a; i++){
        cin >> arr1[i]; 
    }
    for (i=0; i<b; i++){
        cin >> arr2[i];
    }
    
    int idx_a, idx_b;
    idx_a = 0; idx_b = 0;
    for (i=0; i<a+b; i++){
        if (idx_a == a){
            arr3[i] = arr2[idx_b++];
            continue;
        }
        if (idx_b == b){
            arr3[i] = arr1[idx_a++];
            continue;
        }
        if (arr1[idx_a] > arr2[idx_b])
        {
            arr3[i] = arr2[idx_b++];
        }
        else
        {
            arr3[i] = arr1[idx_a++];
        }
    }
    for(int i = 0; i<a+b;i++) cout << arr3[i] << ' ';
    return 0;
}
```

예시

(복잡도 생략 가능)  
시간 복잡도 : O(n+m)

n : 배열 A의 크기
m : 배열 B의 크기

## 회고(지나치게 간단한 문제는 생략 가능)
확실히 c언어로 배열합치기를 풀려고 하니 c언어가 불편하다는 것을 느꼈다. 
머지소트의 배열합치기와 똑같기 때문에 한번 구현하면 여러 번 써먹을 것 같아 문제를 풀었다.
### 간단한 풀이와 접근 방식
핵심은 정렬된 두배열이 필요하다는 것과 
정렬된 두 배열이 갖춰졌다면 앞의 원소만 비교하면 된다는 것이다. 
따라서 모든 원소를 한번씩 확인하기 때문에 시간복잡도가 O(N+M)이 된다. 
### 왜 그러한 풀이를 했는지? 

머지소트 알고리즘을 알았다면 쉬운 아이디어   

## 참고

[알고리즘 문제 해결 전략 세트](https://product.kyobobook.co.kr/detail/S000001032946)에서 적당히 저한테 도움이 될 것 같은 형식으로 번형했습니다. 템플릿을 만든 이유는 단순히 문풀에서 끝나는게 아니라, 뭔가 남았으면 좋겠어서 만들어봤습니다. 
그러나 저는 늘상 문풀에는 약했기 때문에... 아마 도움이 안 될 수도 있을 것 같습니다.
다른 방식의 접근이 좋겠다라고 생각하시면 다른 템플릿을 사용하셔도 무방합니다. 책에서 제시하는 문제 해결 알고리즘 은 아래와 같습니다.

> 1. 문제를 읽고 이해한다.
> 2. 문제를 익숙한 용어로 재정의한다.
> 3. 어떻게 해결할지 계획을 세운다.
> 4. 계획을 검증한다.
> 5. 프로그램으로 구현한다.
> 6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

저는 6에 중점을 두어 템플릿을 만들었습니다.  

### 문제 해결 전략

체계적인 접근을 위한 질문

> 1. 비슷한 문제를 풀어본 적이 있나?
> 2. Brute-force?
> 3. 문제 푸는 과정을 수식화 할 수 있나?
> 4. 문제를 단순화 할 수 있나?(ex. 2d좌표 -> 1d 좌표)
> 5. 그림으로 그려볼 수 있나?
> 6. 문제를 수직으로 표현할 수 있나?
> 7. 문제를 분해/변형할 수 있나?(ex. 제약 조건 분리)
> 8. 역으로 생각할 수 있나?(ex. 사다리게임에서 꽝을 피하는 번호는?)
> 9. 순서를 강제할 수 있나?
> 10. 특정 형태의 답만을 고려할 수 있나?

 
